# Axionic Agency VI.2 — Anchored Causal Verification (ACV)

**Paper:** [VI.2](https://axionic.org/papers/Axionic-Agency-VI.2.html)  
**Date read:** 2026-01-31  
**Series:** VI — Governance and Coordination

---

## TL;DR

Formal specification of **Anchored Causal Verification (ACV)**, a protocol family for verifying that an opaque agent's output was actually generated by a computation that depended on a verifier-controlled anchor disclosed after commitment. ACV provides falsifiable guarantees of temporal ordering and information dependency without requiring interpretability, semantic evaluation, or behavioral scoring.

---

## The Problem

Given an agent whose internal mechanisms are inaccessible or uninterpretable:
- How can a verifier establish that an output was generated by a claimed causal process?
- Rather than by replay, fabrication, or post-hoc synthesis?

### Why Existing Approaches Fail

**Behavioral Verification:**
- Distinct internal processes can produce indistinguishable outputs
- Cached/precomputed responses can pass evaluations without executing the claimed process
- Agents may optimize for passing evaluations rather than preserving causal structure

**Coherence Verification:**
- Filters random fabrication but leaves causal origin unconstrained
- Permits globally planned or post-hoc synthesis
- Commitments and outputs can be produced by disjoint processes

### The Missing Property: Anchored Provenance

Causal provenance requires:
1. **Temporal dependency** on information unavailable at commitment time
2. **Causal incorporation** of that information into revealed material
3. **Falsifiability** via a deterministic predicate without semantic interpretation

---

## Threat Model

### Adversary Classes

1. **Naive Pseudo-Agent** — Static/heuristic, no cross-interaction coherence (trivially defeated)
2. **Coherent Fabricator** — Maintains internal consistency while generating artifacts post-hoc
3. **Split-Brain Agent** — Disjoint internal processes for commitment, explanation, and output
4. **Adaptive Adversary** — Learns verifier strategies, attempts to predict/hedge on anchors
5. **Split-System/Delegated Agent** — Front-end provers outsourcing to back-end systems
6. **Anticipatory Branching Adversary** — Precomputes a large family of candidates, commits to structure allowing post-anchor selection

**Important:** ACV-Core does NOT defeat anticipatory branching in general. Strengthened variants limit it via sequential work costs or anchor entropy requirements.

---

## Protocol Overview

**High-level flow (commit–anchor–reveal–verify):**

1. **Pre-anchor phase:** Prover produces pre-anchor artifact P
2. **Commit phase:** Prover commits cryptographically to P
3. **Anchor disclosure:** Verifier provides unpredictable anchor A
4. **Reveal phase:** Prover produces output O and witness material W
5. **Verification:** Verifier applies deterministic predicate V(C, A, O, W)

### Formal Components

**Pre-Anchor Artifact (P):**
- Transcript artifacts (hash-chained logs)
- Pre-state artifacts (digests of execution state)
- Partial-output templates (output structures with anchor-dependent slots)

**Commitment:** C = Commit(P)
- Must be binding, collision-resistant, generated prior to anchor disclosure

**Anchor (A):**
- High entropy, unpredictable at commitment time, context-bound

**Verification Predicate:** V(C, A, O, W) → {accept, reject}
- No semantic interpretation of O permitted

---

## Anchor–Computation Coupling Patterns

Structural anchor incorporation is necessary but not sufficient. Must prevent **anchor burial** (A included in artifact without constraining the computation that determines O).

### Pattern A: Anchor-Selected Openings
Prover commits to Merkleized trace. After anchor disclosure, verifier derives pseudorandom index set I = PRF(A) and requires openings for those positions plus transition validity proofs.

### Pattern B: Anchor-Parameterized Global Mix
Verifier defines keyed compression H_A(P) over committed artifact, forcing global consistency across trace elements.

### Pattern C: Anchor-Driven Transition Rules
Anchor selects which transition predicate governs the next valid trace step. Makes A affect state evolution, not just logging.

---

## Protocol Variants

### ACV-Core (Temporal Ordering + Anchor Dependency)
Establishes post-commit anchor dependency under V. Enforces liveness and anti-replay but does not guarantee semantic reasoning dependence on anchor.

### ACV-Timebound (Causal Continuity via Sequential Work)
Adds evidence that non-parallelizable work occurred during pre-anchor interval.

**Sequential Work Function:** F is sequentially constrained if computing F(x,d) requires Ω(d) dependent steps.

**Critical:** Work must be **state-coupled** to the computation determining O. If work can be computed in isolation, split-brain Prover can satisfy timebound without constraining unverified computation.

---

## Guarantees

### What ACV Verifies
- Temporal ordering
- Anchor-dependent validity
- (Optional) Evidence of pre-anchor sequential work

### What ACV Does NOT Verify
- Truthfulness
- Correctness
- Alignment
- Benevolence
- Absence of deception beyond causal provenance

---

## Failure Modes

| Mode | Consequence |
|------|-------------|
| Predictable anchors | Prover can precompute compatible artifacts |
| Weak commitments | Prover can adapt artifact post-anchor |
| Deferred computation | ACV-Core permits unless artifact class constrains |
| Small answer space | Anchor entropy alone doesn't prevent branching |
| Resource asymmetry | Resourced adversaries may brute-force |
| Trust boundary leakage | Delegation breaks commitment continuity |

### Domain Applicability
ACV is most effective in **high-entropy generative domains** (LLM-based agentic systems for code synthesis, long-form reasoning, tool-mediated planning). In low-entropy discriminative tasks, ACV is complementary infrastructure.

---

## Open Problems

1. **Anchor entropy vs adversary capacity** — Minimal entropy required to defeat anticipatory branching
2. **Long-horizon and compositional provenance** — Extending across multi-step workflows
3. **State-coupled sequential work in parallel architectures** — Enforcing constraints on GPU/TPU
4. **Provenance vs fidelity: formal separation** — Limits of provenance verification without semantic access

---

## Core Insight

> **ACV does not produce alignment, correctness, or safety. However, it specifies a structural precondition for making any falsifiable claim about those properties in opaque agents.**

> **No framework for agent safety can bypass causal provenance without abandoning falsifiability.**

ACV is the epistemic primitive that makes other alignment claims evaluable.
